{"meta":{"title":"Smilelife","subtitle":"若不坚强，谁替我勇敢","description":null,"author":"关小涛","url":"http://www,xtslift.top"},"pages":[],"posts":[{"title":"Java基础知识（二）","slug":"Java基础知识（二）","date":"2019-05-29T02:17:33.000Z","updated":"2019-05-29T02:18:53.414Z","comments":false,"path":"2019/05/29/Java基础知识（二）/","link":"","permalink":"http://www,xtslift.top/2019/05/29/Java基础知识（二）/","excerpt":"","text":"多线程概述 在一个线程中有多条执行路径 进程：正在执行的程序，他代表着应用程序的执行区域 线程：进程执行路径，就是进程中一个负责程序执行的控制单元。 ​ 线程总是属于某个进程，进程中的多个线程共享进程的内存 关于多线程的问题 jvm启动时多线程还是单线程的，为什么？ 多线程的，他至少启动了两个线程（主线程和垃圾回收线程）垃圾回收机制这个线程不可能是在程序执行完毕后才启动的，否则的话，我们的程序很容易出现内存溢出 调用start方法和run方法区别？ 调用start方法后，线程进入就绪状态，此时线程对象仅有执行资格，还没有执行权。当该线程对象抢到了执行权的时，方可调用run方法，当run方法执行完毕后，线程死亡，不能复生。 线程的随机性的导致原因？ 在同一时刻，CPU只能执行一个程序，这个多线程的程序其实是CPU的高速切换造成的。 什么时候使用多线程？以及创建线程的目的？ 多线程的引入是为了解决现实生活中的需求的，提高解决问题的效率。 当许多对象要对同一有限资源进行操作的时候，我们就要使用多线程 线程状态的内容和每一个状态的特点？ 创建线程对象后，并对这个对象进行了一些初始化工作，当调用了start方法后，这个状态局有了执行资格，但是此时还未获得执行权，进入到了就绪状态。当抢到执行权后进入了运行状态，此时该线程既有了执行资格，又有了执行权。当调用run方法后，此线程进入了死亡状态。当然你也可以调用Stop方法令其强制死亡。在运行状态的时候，如果该线程调用了sleep或者wait等方法后，他会进入到阻塞状态，此时这个对象释放了执行资格和执行权，当它的sleep或者wait等方法后，亦或者调用了notify方法，该线程被唤醒，又进入了就绪状态，如此周而复始。 创建线程的方式 继承Thread类 定义一个类继承Thread类 重写Thread类中的run（）方法，run（）方法里边是多线程要运行的代码； 创建定义的那个类的对象 调用start（）方法开启线程，执行run（）方法里的内容。 123456789101112131415161718192021package com.xtslife.thread;/** * @author 小涛 * @create 2019-05-28 18:55 */public class FirstThread extends Thread&#123; @Override public void run() &#123; for (int i= 0;i&lt;=10;i++)&#123; System.out.println(\"线程\"+getName()+\"正在运行：\"+i); &#125; &#125; public static void main(String[] args) &#123; FirstThread t1 = new FirstThread(); FirstThread t2 = new FirstThread(); t1.start(); t2.start(); &#125;&#125; 线程的声明周期：创建—–阻塞—–运行—-死亡 实现Runnable接口 定义一个类实现Runnable接口 重写Runable接口中的run（）方法，run()方法里是多线程要运行的代码 创建定义的那个类的对象，并将其作为参数放置于Thread类的对象里。线程的任务都封装在Runnable接口子类对象的run方法中，所以要在线程对象创建时就必须明确要运行的任务。 调用start()方法启动线程，执行run()方法里的内容 总结：两种方法的比较：实现Runnable接口，将线程的任务从线程的子类中分离出来，进行了单独的封装，按照面向对象的思想将任务的封装成了对象，避免了java中单继承的局限性。 多线程的安全问题 产生的原因 线程访问的延迟 线程的随机性 线程安全问题表现？原因？解决思想？解决具体的体现 当以个线程对象在执行run方法是的某一操作，其他线程进来了，并发的访问了临界资源，破坏了原子操作，造成了数据的不一致 多线程访问的延迟和线程的随机性产生了线程的安全问题 当某一线程对象进入run方法后，如果能做一个标记，说我已经在理面了，其他哥们（线程对象）你就等着吧，等我操作完了，出来了去掉标记你再进去吧，这样一来。原子操作就不会遭到破坏。 具体体现就是给那个原子操作枷锁，是整个操作同步，不让其他线程对象破坏，保证数据的一致性。 同步解决线程安全问题 同步代码块 同步代码块中的锁可以是任意对象，但是要在成员范围内定义 在局部的话，会导致锁发生变化，因为你每次执行方法，都会重新创建一个对象 同步的前提 至少要有两个线程 同一个锁 同步的好处：提高了安全性 同步的弊端：效率较低 同步函数 同步函数的使用 用synchronized关键字修饰方法即可 123public synchronized void show()&#123; //需要的同步代码块&#125; 同步函数使用的锁 同步函数使用时this对象锁，静态同步函数的锁是（类名.class） 1234567891011121314public class Singleton&#123; private Singleton()&#123;&#125; private static Singleton s = null; public static Singleton getInstance()&#123; if(s==null)&#123; synchronized(Singleton.class)&#123; if(s==null)&#123; s= new Singleton(); &#125; &#125; &#125; return s ; &#125;&#125; 死锁 每个线程都不会释放自己拥有的锁标记，却阻塞在另外的线程所拥有的锁标记的对象池中，就会造成死锁现象。 产生原因 假如有A何B两个锁，在A锁中要使用B锁，在B锁中要使用A锁，而他们都不想让，最终导致了死锁。 因为资源不足 进程运行推进的顺序不合适 资源分配不当 产生死锁的四个条件 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在未使用之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系 只要上述条件之一不满足，就不会发生死锁。 如何解决？ 不同时在A锁中使用B锁，B锁中使用A锁 线程状态 CPU CPU的执行资格：可以被CPU的处理，在处理队列中排队 CPU的执行权：正在被CPU的处理 创建：使用start（）开启线程 运行：具备着执行资格，具备着执行权。 冻结：释放执行权，同时释放执行资格 从运行到冻结的方式 sleep(time),sleep(time)时间到，进入临时阻塞状态（具备着执行资格，但是不具备执行权，正在等待执行权） wait（)线程等待，notify()线程唤醒，进入临时阻塞状态 消亡 从运行到消亡的方式 stop（）终止线程 run（）方法结束，线程任务结束 几个方法的使用 为什么wait(),notify(),notifyAll()都定义在Object类中？ 这些方法存在于同步中 使用这些方法时必须要标识所属的同步锁 锁可以是任意对象，所以任意兑现调用的方法一定定义Object类中 wait()和sleep()的区别？ 对时间指定货而言 wait():可以不指定时间 sleep():必须指定时间 对执行权和锁而言 wait（）：释放了CPU的执行权（资格也没了），释放锁，存储于线程池。 sleep（）:释放CPU执行权，不释放锁（会自动醒） 停止线程 通过控制循环 interrupt()方法 stop已过时，被interrupt取代 守护线程，后台线程 你只要把一个线程设置为守护线程，那么主方法线程结束，不管什么情况，守护线程就结束。 join：加入线程，把执行权抢夺，自己执行完毕，其他线程才可能有机会执行 toString():线程名称，优先级，线程组（是有多个线程组成的，默认的线程组是main） yield（）：让本线程暂停执行，把执行权给其他线程 setProproty(int num):设置线程的优先级 getPrinrity()获取线程的优先级 线程级别1-10 默认级别5 LOCK&amp;Condition接口Scanner类 接收从键盘输入的数据 这是java中提供的类。在util包中 基本用法： Scanner sc = new Scanner(System.in); int a =sc.nextInt();","categories":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www,xtslift.top/tags/java/"}],"keywords":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}]},{"title":"java基础知识（一）","slug":"java基础知识（一）","date":"2019-05-28T11:39:19.000Z","updated":"2019-05-28T11:43:04.024Z","comments":false,"path":"2019/05/28/java基础知识（一）/","link":"","permalink":"http://www,xtslift.top/2019/05/28/java基础知识（一）/","excerpt":"","text":"环境变量path和classpath的作用是什么？path变量是Windows程序文件的目录，作用是指定DOS命令行下命令的路径 classpath变量值是java类文件的目录，作用是指定类搜索路径。JVM就是通过classoath来寻找该类的字节码文件的。 八进制和十六进制与十进制的转换 基本数据类型1字节的：byte boolean 2字节的：short char 4字节的：int float 8字节的：double long 注意：整型默认是int，浮点型默认是double 数据类型的转换 参与运算的数据类型要一致 容量小的类型默认转换为容量大的类型 byte,short,char—int —long —float—double 注意：byte，short，char之间不会互相转换，他们三者在计算时会首先转换为int类型 &amp;&amp;（短路与）和&amp;（与）的区别？ &amp;&amp;左边false了，右边就不操作了 &amp;左边false了，右边还得继续操作 ||和|的区别？ ||左边true了，右边就不操作了 |左边true了，右边还的继续操作 位运算符switch 用于定义选择结构范围： 被选择的结果，该表达式只能有4种类型：byte，short，int，char，enum（jdk5后）,String (JDK7后) default：当所有的case都不匹配时执行default里面的内容 如何自定义函数？ 明确函数的返回值类型 明确参数列表（形参的类型及个数） 函数的重载？ 在同一个类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可 函数的功能一样，仅仅是参与运算的未知内容不同时，可以定义对个函数，却是用统一函数名称 与返回值无关 判断是否重载：函数名相同，参数列表不同（个数和类型） 堆内存中的数据怎么样判断他是否不被使用？ 选择排序： 原理：先从弄0角标位置元素与其他位置元素（自己除外）进行一次比较，每次比较完后，最小值出现在最 左边，并将起始位置后移一个角标，直至次尾角标位。 12345678910111213141516171819202122232425262728package com.xteslife.exel;/** * @author 小涛 * @create 2019-05-26 17:53 */public class ArrayListTest &#123; public static void main(String[] args) &#123; int[] array= new int[]&#123;2, 1, 43, 23, 18&#125;; selectSort(array); for (int x:array) System.out.println(x); &#125; public static void selectSort(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++)&#123; for (int y=i+1;y&lt;arr.length;y++)&#123; if(arr[i]&gt;arr[y])&#123; /*arr[i]=arr[i]+arr[y]; arr[y]=arr[i]-arr[y]; arr[i]=arr[i]-arr[y];*/ arr[i]=arr[i]^arr[y]; arr[y]=arr[i]^arr[y]; arr[i]=arr[i]^arr[y]; &#125; &#125; &#125; &#125;&#125; 冒泡排序 原理：相邻的元素，两两相比，大的后移。每次比较玩，最大值出现在右边。 N个数字要排序完成，总共进行N-1趟排序，每第i趟的排序次数为（N-1）次，所以可以用双循环语句，外层控制循环多少趟，内层控制每一次的循环次数 冒泡排序法口诀 外层循环 0到n-1 //控制比较轮数 N表示元素的个数 内层循环 0到n-i-1 //控制每一轮比较次数 两两比较做交换 1234567891011public static void bubbleSort(int[] arr)&#123; for (int i=0;i&lt;arr.length-1;i++)&#123; for(int y=0;y&lt;arr.length-i-1;y++)&#123; if (arr[y]&gt;arr[y+1])&#123; arr[y]=arr[y]^arr[y+1]; arr[y+1]=arr[y]^arr[y+1]; arr[y]=arr[y]^arr[y+1]; &#125; &#125; &#125; &#125; 成员变量和局部变量的区别 作用范围 成员变量作用于整个类 局部变量只作用于它所属的范围 生命周期和位置 成员变量存储在堆内存中，是属于对象的，随着对象的存在而存在，随着对象的消失而消失 局部变量存储在栈内存中，是属于它所属的范围，使用完立即被释放 初始值 成员变量都有默认初始值 局部变量没有默认值，要想使用必须遵循 先定义（声明）再赋值，最后使用 构造方法 自定义类中如果没有构造方法，系统会默认给出一个午餐构造方法 如果你给定了构造方法，系统将不再提供无参构造方法了 建议：每次我们都手动给出无参构造方法 this的三种使用场景 局部变量隐藏成员变量 构造方法中使用this 比较年龄 内存图代码块定义 他是由一对{}括起来的代码 分类： 局部代码块：用在局部可以及时释放内存，提高效率 构造代码块：每个构造方法运行时都会自动调用构造代码块，可以对所有对象初始化 静态代码块：随着类的加载而执行，而且只执行一次，优先于主方法 假如我们有一个Persion对象，请问Persion p = new Persion(); 在内存中到底做了什么？ 步骤： 把Persion.class问价加载近内存 在栈内存空间开批一个小空间，存储P变量 在堆内存中开辟空间。创建对象 对对象中的成员变量进行默认初始化 执行构造代码块，如果没有构造代码块，就不执行 对对象中的成员变量进行赋值 把对象构造初始化完毕 将对象在堆内存的首地址赋给栈内存变量P static特点： 随着类的加载而加载 优先于对象存在 被所有对象共享 可以直接被类名调用 注意事项： 静态成员只能访问静态成员 静态方法中不能有this和super关键字 主函数是静态的 静态变量和非静态变量的区别A：静态变量随着类的加载而加载，随着类的消失而消失。生命周期最长。 ​ 非静态变量随着对象的创建而存在，随着对象的消失而消失。 B：静态变量和类相关，是所属于类的，可以直接被类名调用，也可以被对象名调用。 也称为类变量。 ​ 非静态变量和对象相关，是所属于对象的，只能被对象名调用。称为实例(对象)变 量。 C：静态变量存储于方法区中的静态区。 ​ 非静态变量存储于对象的区域，在堆内存中。 D：静态变量的数据被所有的对象共享。 ​ 非静态变量是每个对象特有的数据。 某个成员方法访问了静态成员，那么该方法就必须定义为static修饰的。 在IDEA中怎么制作帮助文档单例设计模式 保证对象在内存中只有一个 如何保证？ 不能让其他类来创建对象 本类中要创建一一个本类的对象 对外提供公共的方法 什么时候是用呢？ 配置文件 单列的两种模式 第一种:饿汉模式 123456789101112class Teacher&#123; //创建一个本类对象 private static Teacher t = new Teacher(); //为了保证其他类不能够创建对象（将构造方法私有化） private Teacher()&#123;&#125; //为了让外界能够通过类名直接调用 public static Teacher getInstance()&#123; return t; &#125; Teacher t1 = Teacher.getInstance(); Teacher t2 = Teacher.getIndtance();&#125; 第二种方式：懒汉式 12345678910111213141516171819class Teacher&#123; //创建一个本类对象 private static Teacher t = null; //为了保证其他类不能够创建对象 private Teacher()&#123;&#125; //为了外界能够通过类名直接调用 public static Teacher getInstance()&#123; if(t==null)&#123; Synchronized(Teacher.class)&#123; if(t==null)&#123; t = new Teacher(); &#125; &#125; &#125; return t; &#125; Teacher t1 = Teacher.getInstance(); Teacher t2 = Teacher.getInstance();&#125; 注意：开发一般使用饿汉式，第二种在多线程的时候会有安全隐患 面试一般考懒汉式（延迟加载） 继承特点： Java只支持单继承，不支持多继承（子类调用父类的不确定性）但是它支持多层继承 父类有的子类也有，而且子类可以改变父类的属性值，重写父类的成员方法，父类没有的子类也可以增加 父类的属性和方法可以继承，但是构造放噶不能继承，子类的构造方法隐式的调用父类的无参构造方法，当父类没有无参构造方法时，子类需要使用super来显示的调用父类的构造方法。 继承后的Fu和Zi的关系 遵循就近原则 重写和重载的方法 重载： 在同一个类中 方法名相同，参数类表不同 重写： 存在于父子类中 方法的声明一致（名称和参数） 子类的访问权限不能低于父类的访问权限 注意： 父类中的私有方法不可以被覆盖 在子类覆盖方法中，要想继续使用被覆盖的父类方法可以通过supper.方法名获取。 This代表本类对象的引用 super代表父类所属的空间，并不是一个对象 结论：父类的构造函数，既可以给本类对象初始化，也可以给子类对象初始化。 final final修饰的类不能被继承‘ final修饰的成员变量不能被重写 final修饰的成员变量是一个常量 抽象方法 只有功能声明，没有功能主体的方法称为抽象方法 特点： 抽象类和抽象方法都必须用abstract关键字修饰 抽象方法一定要在抽象类中 一个类继承了抽象类，那么该类实现类中的所有抽象方法 注意：抽象关键字abstract不可以和final，private.static关键字共存。 接口 概述：接口是特殊的抽象类，所有的属性都是公开静态常量（全局常量），所有的方法都是公开的抽象方法而且没有构造方法。 特点： 接口是对外暴露的规则 接口是程序功能的扩展 接口的出现降低耦合性 接口可以用来多实现 类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口。接口与接口之间可以有继承关系。 注意： 如果接口默认的方法是Public和abstract可以省略不写，但是类在实现接口时，不可省略public 类实现接口的时候，要么全部实现接口中的方法，要么类本身定义为抽象类，接口不能被实例化，所有成员有固定修饰符。 接口和抽象类的区别？—都是不断向上抽取出来的 抽象类只能单继承，接口可以多实现 抽象类中可以有非抽象方法。抽象类中可以定义变量和常量。接口中的方法都是抽象方法，接口中只能有静态常量。因为接口中的方法都有默认修饰符：public abstract ;接口中的成员变量都有默认修饰符:Public static final 抽象类中定义的是一个体系的共性功能，接口中通常定义的是对象中的扩展功能。 接口的出现避免了单继承的局限性 抽象类被继承表示的是：is a的关系，叫做：xx是yy的一种。接口被实现表示的是：like a 的关系。叫做xx像yy一种。 多态 概述：事物的多种形态，它分为静态多态（重载）和动态多态（对象的多态） 特点： 体现 多态用在方法的参数上m(A a)可以用A的任何一个子类对象作为参数 多态用在方法的返回值上，方法的返回值可能是A的子类对象 前提: 类与类（接口）之间有继承（实现）关系 必须有重写 父类引用指向子类对象 多态的成员变量（不理解） 成员变量：编译看左边，运行也看左边 成员方法：编译看左边，运行看右边 静态方法：编译看做边，运行也看左边 好处：提高了代码的扩展性，便于后期可维护性，把不同的子类对象都看成是父类的对象，屏蔽子类差异，使得程序更加通用 弊端：只能使用子类中和父类中同名的方法，对于子类特有的方法试用不了。 ClassCastException:在进行子类特有的方法使用时，要进行向下转型，转型前一定要做判断，否则容易发生此异常增强程序的健壮性 异常throws,throw抛出区别：一旦执行throw语句，就结束功能 使用位置 throws在方法的声明上使用 throw在方法体内使用 使用格式 throws后面跟的使用异常的类名 throw后面跟的是对象。格式 throw new 异常类名（参数） 联系 有throws不一定有throw 有throw一定有throws Exception的分类 Exception：这种类型的异常，如果抛出，在编译的时候就会检查，此类异常需要编写针对性的处理代码进行处理。 RuntimeException：这种类型的异常，如果抛出，在编译的时候不检查，运行的时候直接处理，这种异常必须通过修改代码才能解决，所以一般针对这种异常，我们不处理，jvm处理。 自定义异常 继承自Exceptioin或者RunException必须的 在自定义异常里面，提供一个带参构造。 12345class MyException extends Exception&#123; MyException()&#123;&#125; MyException(String message)&#123; super(message); &#125; 测试题 char 型变量中能不能存贮一个中文汉字？为什么？ 答：char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字， 所以，char 型变量中当然可以存储汉字。不过，如果某个特殊的汉字没有被包含在 unicode 编码字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。(unicode 编码占用两个 字节，所以，char 类型的变量也是占用两个字节。)  静态变量和实例变量的区别？ (1)作用范围 A：静态变量随着类的加载而加载，随着类的消失而消失。生命周期最长。 B：实例变量随着类的创建而加载，对象消失，实例变量消失。 (2)存储空间 A：静态变量存储在方法区中的静态区，被所有实例共享。 B：实例变量存储在堆内存中，只被某一个对象所特有。 (3)调用方式 A：静态变量既可以通过对象名调用，也可以通过类名直接调用。 B：实例变量只能通过对象名调用。  abstract class 和 interface 有什么区别？ 答: A：抽象类只能单继承,接口可以多实现。 B：抽象类中可以有非抽象方法,抽象类中可以定义变量和常量。接口中的方法都是抽象的。 接口中只能有静态常量。接口中的方法都有默认修饰符：public abstract 接口中的成员变 量都有默认修饰符：public static final C：抽象类中定义的是一个体系的共性功能,接口中通常定义的对象中的扩展功能。 D：接口的出出现避免了单继承的局限性。 E：抽象类被继承表示的是：is a 的关系。叫做：xx 是 yy 的一种。接口被实现表示的是： like a 的关系。叫做：xx 像 yy 一种。  面向对象的特性有哪些，分别阐述说明？ (1)抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前 目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。 抽象包括两个方面，一是过程(行为)抽象，二是数据(属性)抽象。 (2)继承：继承是一种层次模型，允许和鼓励类的重用，它提供了一种明确表述共性的方法。 对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类62 称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继 承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 (3)封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象 计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过 一个受保护的接口访问其他对象。 (4)多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性 (重载)和对象多态性(子父类的重写)。多态性语言具有灵活、抽象、行为共享、代码共享的优 势，很好的解决了应用程序方法同名问题。","categories":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www,xtslift.top/tags/java/"},{"name":"基础","slug":"基础","permalink":"http://www,xtslift.top/tags/基础/"}],"keywords":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}]},{"title":"hexo发布文章五步曲","slug":"hexo发布文章五步曲","date":"2019-05-22T00:45:51.000Z","updated":"2019-05-22T00:53:14.899Z","comments":false,"path":"2019/05/22/hexo发布文章五步曲/","link":"","permalink":"http://www,xtslift.top/2019/05/22/hexo发布文章五步曲/","excerpt":"","text":"hexo发布文章五步曲 第一步 使本地可以正常的访问到文章 在博客根目录输入hexo s 命令 第二步 新建文章 在博客根目录输入hexo new &quot;hexo发表文章五步曲”命令 对应新建的MD文件在hexo\\source\\_post目录中 第三步 清除缓存文件db.json和已生成的静态文件public 在博客根目录输入hexo clean 命令 第四步 生成网站静态文件到默认设置的 public 文件夹 在博客项目根目录输入hexo g命令 第五步 生成网站静态文件，并部署到设定的仓库 在博客项目根目录输入hexo d命令","categories":[{"name":"工具","slug":"tool","permalink":"http://www,xtslift.top/categories/tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www,xtslift.top/tags/hexo/"},{"name":"文章","slug":"文章","permalink":"http://www,xtslift.top/tags/文章/"}],"keywords":[{"name":"工具","slug":"tool","permalink":"http://www,xtslift.top/categories/tool/"}]},{"title":"今生今世","slug":"今生今世","date":"2019-05-21T23:59:14.000Z","updated":"2019-05-22T00:17:56.437Z","comments":false,"path":"2019/05/22/今生今世/","link":"","permalink":"http://www,xtslift.top/2019/05/22/今生今世/","excerpt":"","text":"​ 我最忘情的哭声有两次 ​ 一次，在我生命的开始 ​ 一次，在你生命的告终 ​ 第一次，我不记得 ​ 是听你说的 ​ 第二次，你不会晓得 ​ 我说也没用 ​ 但这两次哭声的中间 ​ 有无穷无尽的笑声 ​ 一遍一遍又一遍 ​ 回荡了整整30年 ​ 你都晓得，你都记得","categories":[{"name":"生活","slug":"life","permalink":"http://www,xtslift.top/categories/life/"}],"tags":[{"name":"母亲","slug":"母亲","permalink":"http://www,xtslift.top/tags/母亲/"},{"name":"余光中","slug":"余光中","permalink":"http://www,xtslift.top/tags/余光中/"},{"name":"经典诗歌","slug":"经典诗歌","permalink":"http://www,xtslift.top/tags/经典诗歌/"}],"keywords":[{"name":"生活","slug":"life","permalink":"http://www,xtslift.top/categories/life/"}]},{"title":"TCP与UDP协议","slug":"TCP与UDP协议","date":"2019-04-29T03:06:54.000Z","updated":"2019-04-29T03:13:04.489Z","comments":false,"path":"2019/04/29/TCP与UDP协议/","link":"","permalink":"http://www,xtslift.top/2019/04/29/TCP与UDP协议/","excerpt":"","text":"TCP与UDP协议 TCP：传输控制协议 一种以固接连线为基础的协议，它提供两台计算机间可靠的数据传送。 TCP可以保证数据确实到达，抵达的数据的排列顺序和送出时的顺序相同 UDP：用户数据报协议 无连接通讯协议，广播的方式发送 端口和套接字端口 一台计算机只有单一的连接到网络的物理连接，所有的数据都通过此链接对内、对外送达特定的计算机。这就是端口。 网络程序设计中的端口并非真实的物理存在，而是一个假想的连接装置。端口被规定为0~65535之间的整数。 套接字 网络程序中的套接字socket用于将应用程序和端口连接起来，套接字是一个假象的连接装置 TCP程序设计常用类 InetAddress类的常用方法 方法 返回值 说明 getByName(String host) InetAddress 获取与host对应的InetAddress对象 getHostAddress() String 获取InerAddress对象所包含的IP地址 getHostName() String 获取IP地址的主机名 getLocalHost() InetAddress 返回本地主机的Inetaddress对象 InetAddress类的方法会抛出UnknownHostException异常，所以必须进行异常处理。这个异常在主机不存在或网络连接错误时发生。 ServerSocket类 ServerSocket类用于表示服务器套接字，其主要功能是等待来自网络上的请求，它可通过指定端口来等待套接字。 服务器套接字一次可以与一个套接字连接。 如果多台客户机同时提出连接请求，服务器套接字会将请求连接的客户机存入队列，然后从中取出套接字与服务器新建的套接字连接起来。队列的默认大小是50； ServerSocket类的主要构造方法 ServerSocket（)：创建非绑定服务器套接字 ServerSocket（int port）:创建绑定到特定端口的服务器套接字 客户端输出则服务端就是输入，服务端输出则客户端就是输入 accept（）方法会阻塞线程的继续执行，直到接收到客户端的请求。 创建线程的三种方法（常用的只有两种） 1）继承Thread类创建线程 2）实现Runnable接口创建线程 3）使用Callable和Future创建线程 ————————继承Thread类创建线程——————— 通过继承Thread类来创建并启动多线程的一般步骤如下 定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。 创建Thread子类的实例，也就是创建了线程对象 启动线程，即调用线程的start()方法 123456789101112131415161718public class MyThread extends Thread&#123;//继承Thread类 public void run()&#123; //重写run方法 &#125;&#125;public class Main &#123; public static void main(String[] args)&#123; new MyThread().start();//创建并启动线程 &#125;&#125; ————————实现Runnable接口创建线程——————— 通过实现Runnable接口创建并启动线程一般步骤如下： 定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体 创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象 第三步依然是通过调用线程对象的start()方法来启动线程 123456789101112131415161718192021222324252627public class MyThread2 implements Runnable &#123;//实现Runnable接口 public void run()&#123; //重写run方法 &#125;&#125;public class Main &#123; public static void main(String[] args)&#123; //创建并启动线程 MyThread2 myThread=new MyThread2(); Thread thread=new Thread(myThread); thread().start(); //或者 new Thread(new MyThread2()).start(); &#125;&#125; ————————使用Callable和Future创建线程——————— 和Runnable接口不一样，Callable接口提供了一个call（）方法作为线程执行体，call()方法比run()方法功能要强大。（不常用）","categories":[{"name":"工具","slug":"tool","permalink":"http://www,xtslift.top/categories/tool/"}],"tags":[{"name":"tcp","slug":"tcp","permalink":"http://www,xtslift.top/tags/tcp/"},{"name":"udp","slug":"udp","permalink":"http://www,xtslift.top/tags/udp/"},{"name":"网络编程","slug":"网络编程","permalink":"http://www,xtslift.top/tags/网络编程/"}],"keywords":[{"name":"工具","slug":"tool","permalink":"http://www,xtslift.top/categories/tool/"}]},{"title":"git的学习","slug":"git的学习","date":"2019-04-29T03:02:29.000Z","updated":"2019-04-29T03:13:18.186Z","comments":false,"path":"2019/04/29/git的学习/","link":"","permalink":"http://www,xtslift.top/2019/04/29/git的学习/","excerpt":"","text":"github的学习 感觉再不学习这个工具要不行了，各种demo都挂载GitHub上，今天刻意的花时间来学习。在简书上有个大牛分享了教程，开篇就是全英文，来吧，慢慢解决。 学习要点 仓库的创建和使用 启动和管理新的分支 对文件进行更改并将其作为提交推送到GitHub 打开并合并一个pull请求 Git和GitHub详细教程一、概述 协同修改 多人并行不悖的修改服务器端的同一个文件，数据备份 不仅保存目录和文件的当前状态，还能够保存每一个提交过的历史状态 版本管理 在保存每一个版本文件信息的时候要做到不保存重复的数据，以节约存储空间，提高运行效率。这方面SVN采用的是增量式管理的方式 而Git采取了文件系统快照的方式。 权限控制 对团队中参与开发的人员进行权限控制 对团队外开发者贡献的代码进行审核—Git独有 将本地文件恢复到某一个历史状态 分支管理 允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率 二、版本控制介绍 版本控制工具 集中式版本控制工具;CVS SVN VSS 集中式版本控制工具的模式主要是将代码专门放在一个服务器上 分布式版本控制工具：Git Mercurial、 Bazaar、 Darcs 三、Git历史 Git官网：https://git-scm.com/ Git优势 大部分操作在本地完成，不需要联网 完整性保证 尽可能添加数据而不是删除或修改数据 分支操作非常快捷流畅 与linux命令全面兼容","categories":[{"name":"工具","slug":"tool","permalink":"http://www,xtslift.top/categories/tool/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www,xtslift.top/tags/git/"},{"name":"github","slug":"github","permalink":"http://www,xtslift.top/tags/github/"}],"keywords":[{"name":"工具","slug":"tool","permalink":"http://www,xtslift.top/categories/tool/"}]},{"title":"java 必会知识点","slug":"java-必会知识点","date":"2019-04-29T02:53:35.000Z","updated":"2019-04-29T02:55:35.520Z","comments":false,"path":"2019/04/29/java-必会知识点/","link":"","permalink":"http://www,xtslift.top/2019/04/29/java-必会知识点/","excerpt":"","text":"java学习 工作相关使用到的JDK类及其相关源码、机制 设计模式，设计模式在工作中用到了哪些，具体使用场景 并发类的相关知识，线程安全、锁机制、信号量、闭锁、栅栏、线程池等 框架相关，Spring相关机制、Spring MVC相关机制、MyBatis相关机制、使用的细节点、框架实现原理等 JVM，内存布局、垃圾识别算法、垃圾回收算法、垃圾收集器、类加载机制、内存模型、出现内存问题时定位问题的方法等 数据库的基本数据类型、索引机制、各引擎区别、锁机制、慢SQL定位及优化等 缓存机制，这里的机制指的是缓存加载、缓存击穿、缓存雪崩这些机制及其相关应对方案，用过Redis、MemCache的最好理解一下它们的原理或者缓存提供的一些高级功能，集群如何实现 分布式的一些知识，比如CAP理论、数据一致性的几种解决方案、分布式事务如何处理、分库分表怎么做、现有的相关解决方案等 NIO的作用，epoll模型是否知道一些，Netty的相关机制、Netty相比原生NIO的优点、半包拆包、断线重连解决方案等 Web相关，Get与Post的区别、转发与重定向的区别、跨域问题如何解决、如何保证接口幂等性等 网络层相关，三次握手和四次握手、全连接队列和半连接队列、负载均衡算法等 其他中间件，MQ作用和使用场景、服务化治理框架的作用和使用场景、配置中心的作用和使用场景等 数据结构，数组、链表、栈、队列、树等优缺点，在什么场景下使用什么数据结构 Linux相关知识，基本命令的使用，排查日志、定位问题，项目或者第三方组件的基本运维等 java必看书籍 Thinking in java Effective java Head First 设计模式 算法（第四版） 高性能mysql 深入理解java虚拟机 敏捷软件开发：原则、模式与实践 重构–改善既有的代码设计 Clean Code 深入分析java web技术内幕 测试驱动开发 by Example","categories":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www,xtslift.top/tags/java/"},{"name":"必会","slug":"必会","permalink":"http://www,xtslift.top/tags/必会/"}],"keywords":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}]},{"title":"微信小程序开发","slug":"微信小程序开发","date":"2019-04-29T02:49:51.000Z","updated":"2019-04-29T02:52:38.897Z","comments":false,"path":"2019/04/29/微信小程序开发/","link":"","permalink":"http://www,xtslift.top/2019/04/29/微信小程序开发/","excerpt":"","text":"微信小程序的五个版本 预览版本 开发版本 体验版本 审核版本 线上版本 开发者ID：wx22a6116c2c607dd5 demo 基本文件结构 CSS的使用限制 自适应单位rpx 全局样式 App.json配置文件 Flex布局等 根目录下有三个文件app.js app.json app.wxss，一个小程序项目必须有这三个描述App的文件。 注意：必须放在应用程序的根目录 文件 必填 作用 app.js 是 小程序逻辑文件 app.json 是 小程序配置文件 app.wxss 否 全局公共样式文件 页面构成该文件一个小程序由若干个页面文件构成，每个页面可由四个文件构成，分别是,js .wxml .wxss .json文件 文件类型 必填 作用 js 是 页面逻辑 wxml 是 页面结构 wxss 否 页面样式表 json 否 页面配置 开发注意： 要显示页面，必须让小程序的框架知道这个页面的存在，以及这个页面的具体位置。 页面的JS文件是不可以完全为空的，否则小程序会报错 页面的json文件同样不能为空 创建页面的快捷方式：如果app.json文件下的pages数组里的页面路径，指向的是一个不存在的文件，那么MINA框架会自动创建这个页面的四个文件。 组件： view作为容器来使用类似于HTML中的div标签 text组件用来显示一段文本 image组件用来显示一张图片 想对路径和绝对路径： 绝对路径以“/‘’开头，””/“代表根目录 相对路径，路径中../表示向上一级 图片的存放： 真实项目中，图片资源尽量不要存储在小程序的项目中，因为小程序的大小不能超过1MB。应该将图片存放你在服务器上，让小程序通过网络来加载图片资源。 小程序所支持的CSS选择器 选择器 样例 样例描述 .class .sample 选择所有拥有class=”sample”的组件 #id #sample element view 选择所有view的组件 ::after view::after 在view组件后边插入内容 ::before view::before 在view组件前边插入内容 本地资源在wxss中是无法使用的。 Flex布局 W3C提出 让页面布局更加简单，很好的支持响应式布局。 Flex也成为弹性布局，主要作用在容器上。 设置display:flex是应用一切弹性布局属性的先决条件。 flex-direction这个属性指定view内元素的排列方向。 确定主轴方向 row：主轴水平，方向为自左向右 column：主轴水平，方向为自右向左 row-reverse：主轴垂直，方向自上而下 column-reverse：主轴垂直，方向自下而上 iphoone6的尺寸下设计： 1物理像素=1rpx=0.5px 逻辑像素pt 物理像素px 以iphone6为例，模拟器理给出的分辨率是375x667; Dpr:2 iphone6的水平方向有375个逻辑像素点，而竖直方向有667个逻辑像素点，每个逻辑像素点包含2个物理像素点。 page代表着整个页面的容器，如果想对页面整体做样式或者属性设置，name应该考虑page这个页面的根元素。 window配置项可用来设置小程序的状态栏、导航栏、标题和窗口的背景色。 未完待续…..","categories":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://www,xtslift.top/tags/微信/"},{"name":"小程序","slug":"小程序","permalink":"http://www,xtslift.top/tags/小程序/"},{"name":"开发","slug":"开发","permalink":"http://www,xtslift.top/tags/开发/"}],"keywords":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}]},{"title":"诗词几首","slug":"诗词几首","date":"2019-04-29T02:42:02.000Z","updated":"2019-04-29T02:49:10.227Z","comments":false,"path":"2019/04/29/诗词几首/","link":"","permalink":"http://www,xtslift.top/2019/04/29/诗词几首/","excerpt":"","text":"《秦楼月》 李白 箫声咽，秦娥梦断秦月楼。秦月楼，年年柳色，霸陵伤别。 乐游原上清秋节，咸阳古道音尘绝。音尘绝，西风残照，汉家陵阙。 《生查子》 牛希济 春山烟欲收，天澹星稀少。残月脸边明，别泪临清晓。 语已多，情未了，回首犹重道：记得绿罗裙，处处怜芳草。 《浪淘沙》 李煜 窗外雨潺潺，春意阑珊，罗衾不耐五更寒，梦里不知身是客，一晌贪欢。 独自莫凭栏，无限江山，别时容易见时难，流水落花春去也，天上人间。 《虞美人》 李煜 春花秋月何时了，往事知多少。小楼昨夜又东风，故国不堪回首月明中。 雕栏玉砌应犹在，只是朱颜改。问君能有几多愁，恰似一江春水向东流。 《蝶恋花》 冯延巳 六曲阑干偎碧树，杨柳风轻展尽黄金缕；谁把钿筝移玉柱，穿帘海燕惊飞去。 满眼游丝兼落絮，红杏开时，一霎清明雨，浓睡觉来不慵不语，惊残好梦无处寻。 《蝶恋花》 冯延巳 莫道闲情抛掷久，每到春来惆怅还依旧；日日花前常病酒，不辞镜里朱颜瘦。 河上青芜堤上柳，为问新愁何事年年有；独立小桥风满袖，平林新月人归后。 李白词二首 《菩萨蛮》 平林漠漠烟如织，寒山一带伤心碧。暝色入高楼，有人楼上愁。 玉梯空拧立，宿鸟归飞急。何处是归程？长亭连短亭。 《忆秦娥》 箫声咽。秦娥梦断秦楼月。秦楼月。年年柳色。霸陵伤别。 乐游原上清秋节。咸阳古道音尘绝。音尘绝。西风残照。汉家陵阙。","categories":[{"name":"文艺","slug":"literature","permalink":"http://www,xtslift.top/categories/literature/"}],"tags":[{"name":"李白","slug":"李白","permalink":"http://www,xtslift.top/tags/李白/"},{"name":"宋词","slug":"宋词","permalink":"http://www,xtslift.top/tags/宋词/"}],"keywords":[{"name":"文艺","slug":"literature","permalink":"http://www,xtslift.top/categories/literature/"}]},{"title":"java EE复习","slug":"java-EE复习","date":"2019-04-29T02:21:42.000Z","updated":"2019-04-29T03:06:05.418Z","comments":false,"path":"2019/04/29/java-EE复习/","link":"","permalink":"http://www,xtslift.top/2019/04/29/java-EE复习/","excerpt":"","text":"知识点一： Response 通过 response 输出中文 通过 response 实现请求重定向 通过 response 输出认证图片（选做） Request 看 request 文档，查看获取请求方式 getMethod、请求资源 getRequestURI、请求头 getHeader、请求参数 getParameter 的方法 如何向客户机输出不同类型的表单，以收集客户机的数据, 并在服务器端获取（必做） 获取中文数据 (包括中文数据) 理解请求转发和重定向区别 知识点二：请求转发forward 和 请求重定向redirect 区别 ？？？ 1) 转发一次请求 一次响应； 重定向两次请求 两次响应2) 转发URL地址 不变，重定向URL地址改变第二个资源地址3) 转发只能转发给同一个网站内部资源，重定向可以定向到任何网站4) 转发中/属于服务器内部路径 不写工程名，重定向/来自客户端必须要写工程名 知识点三：获取客户机信息 getRequestURL方法 :返回客户端发出请求完整URL getRequestURI方法 :返回请求行中的资源名部分 getQueryString方法 : 返回请求行中的参数部分 getRemoteAddr（重点） 返回发出请求的客户机的IP地址 getMethod() （重点） 获取客户机请求方式 getContextPath()（重点） 获得工程虚拟目录名称 知识点四：Session 和 Cookie 的主要区别 Cookie 是把用户的数据写给用户的浏览器。cookie 基于客户端，不安全，并且大小和个数的限制。 Session 技术把用户的数据写到用户独占的 session 中（服务器端）。session 域对象，范围一次会话范围，存个人相关的数据。 Session 对象由服务器创建，开发人员可以调用 request 对象的 getSession 方法得到 session 对象。 session API setAttribute(String name, Object value) Object getAttribute(String name) String getId() 获取 seesion 的唯一的 ID void invalidate() 销毁的 seesion session 为每个浏览器保存数据 session的创建和销毁 创建session : 第一次访问资源，调用request.getSession() session销毁 的三种方法: 非正常关闭服务器 session的过期，默认是30分钟。(tomcat/conf/web.xml) session的域对象 ServlerContext ：代表整个web应用，数据库链接 session ：一次会话，存放个人的信息。 request ：一次请求，存放错误处理。 知识点五：Servlet 的数据访问范围 ServletContext 存放的数据，共享于整个 web 应用中。 只要服务器不重启，存放在 ServletContext 中的数据就一直有效，并且所有用户都可以访问 ServletContext 中存放的数据。 因为同一 web 应用仅有一个 ServletContext，当多用户访问时，会有线程问题，ServletContext 不是线程安全的，当然我们也可以使用 synchronized 关键字来同步 doGet() 和 doPost() 方法，解决线程安全问题。 例如：数据库的连接、当前在线用户数、系统管理员联系方式。 Session 是同一用户在一次会话期间内，在 web 应用的各个资源之间都可以共享的数据范围。使用 Session 就不需要像 Request 那样通过转发请求来传递数据，当使用链接或者新提交 Form 表单时，原来 Session 中的数据，对于当前用户仍然可用。 注意：Session 中的数据仅对当前用户可见。 存放在 Request 之中的数据存活范围 \\1. 使用HttpServletRequest对象的getRequestDispatcher( )方法得到 RequestDispatcher 对象，并调用该对象的 forward() 方法和 include() 方法时。当前页面的 HttpServletRequest 对象中数据可以在目标页面使用。 \\2. 当使用链接，或者重新提交一个 Form 时，当前的页面的 Request 对象就会被销毁，其中的数据全部丢失，并生成新的请求。 知识点六：JSP的内置对象（9个）request response session application out pageContext page config exception 内置对象 真实的对象 方法 request HttpServletRequest setAttribute() getAttribute() response HttpServletResponse addCookie() getWriter() session HttpSession setAttribute() getAttribute() application ServletContext setAttribute() getAttribute() config ServletConfig getInitParameter() getInitParameterNames() exception Throwable getMessage() page this(HttpServlet)Object （不使用对象） out JspWriter write() print() pageContext PageContext setAttribute() getAttribute() 向JSP的四个作用域范围内存数据。 Servlet中有三个域，而JSP有四个域。 JSP中多了pageContext的域范围，代表当前页面范围。 JSP的四种数据范围 ServletContext 整个web应用 application 应用范围 session 一次会话,会话范围 request 一次请求,请求范围 pageContext 当前页面,page范围 案例一：实现文件下载（初级下载） 对于超链接，浏览器可以解析直接打开。 对于弹出下载窗口： 前提条件：先准备一个文件。 读取文件，读入到输入流中。 通过response读出到浏览器端。 设置头信息 Content-Disposition attachment;filename=文件名称 以附件的形式打开 案例二：session 案例 使用 Session 完成简单的购物车功能 购物车–&gt;Map&lt;String,Integer&gt; cart - 购物车–&gt; 把购物车存入 seesion 中。 获取数据 判断是否是第一次访问 session.getAttribute(“cart”); 如果第一次访问，cart 创建一个购物车，放入商品的名称和数量 如果不是第一次访问，cart!=null 判断是否包含该商品？ 如果包含，数量拿出来，++，放回去，存入 seesion 中 如果不包含，正常放入到购物车中。存入 seesion 中 继续购物或者结算 ​ 案例三：利用 Session 实现一次性验证码用户登陆 一次性验证码的主要目的就是为了限制人们利用工具软件来暴力猜测密码。 服务器程序接收到表单数据后，首先判断用户是否填写了正确的验证码，只有该验证码与服务器端保存的验证码匹配时，服务器程序才开始正常的表单处理流程。 密码猜测工具要逐一尝试每个密码的前题条件是先输入正确的验证码，而验证码是一次性有效的，这样基本上就阻断了密码猜测工具的自动地处理过程。","categories":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www,xtslift.top/tags/java/"},{"name":"web","slug":"web","permalink":"http://www,xtslift.top/tags/web/"},{"name":"复习","slug":"复习","permalink":"http://www,xtslift.top/tags/复习/"}],"keywords":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}]},{"title":"断舍离","slug":"断舍离","date":"2019-04-27T13:09:52.000Z","updated":"2019-04-27T13:33:36.351Z","comments":false,"path":"2019/04/27/断舍离/","link":"","permalink":"http://www,xtslift.top/2019/04/27/断舍离/","excerpt":"","text":"01思考 第一，断舍离是什么，它能给人带来怎样的变化？ 第二，我们为什么会舍不得扔东西？ 第三，如何断舍离？ 02 书中金句 断舍离是维持生活状态的工作，也是自我探索的工具。试着使用高于自我形象的物品。使用精挑细选的自己喜爱的东西，这样就能够挖掘出全新的自己，也就是说，物品并不只是用来使用的，而是要进入更高的阶段，最大限度地利用物品的力量。 拥有就是深信不疑的错觉，理解了拥有本质，就能自然地涌出珍惜物品的心情。 在面对一大堆物品，不知道该怎么分类，毫无头绪的时候，可以按照三分法。必需品，备用品和没用品进行分类，如果已经淘汰了，没用的物品，这个时候就只剩下。必需品和备用物品。 03 精华笔记一般的整理收纳术把焦点放到物品上，更重视方法和工具。比如家里有多少物品都没关系，只要用盒子装起来就可以；再比如，有多少物品都要想办法展示出来；而断舍离则以人为主，帮助我们探索：自己想成为什么样的人，要过什么样的生活，最终真正喜欢上自己。 断舍离是什么？ 想记住断舍离的概念，一个公式就足够。断＝断绝不需要的东西，减少不必要的购买，舍＝舍弃多余的废物，从现有物品中做减法，离＝脱离对物品的执着。断+舍=离。但是，是不是少买东西，不敢轻易买东西就是做到断了呢？多淘汰旧物品就是做到舍了呢？其实，断舍离并不是倡导人们去过朴素、贫乏的生活，它还包含了一层重要的意义：升级。 所谓升级，是重新思考你和物品的关系，站在更高水准，使用高于自我形象的物品。当你使用精挑细选的，非常喜爱的东西时，能够挖掘出全新的自己。也就是说，物品并不只是拿来用的，要最大限度地利用物品的力量。 不断舍离会怎样？ 首先，没有收拾的屋子就像便秘，会产生心情废气。在便秘的时候，病菌会不断释放毒素，这些毒素会被肠道再次吸收，而后扩散到身体各个部位，引起不适。换句话说，房间里满是破烂，就会释放出影响心情的废气，让你不知不觉间陷入慢性中毒。 第二，环境中会产生灰尘垃圾，因为到处都是不喜欢的东西，你根本不愿意擦拭和保养，时间长了肯定会覆盖很多灰尘、霉菌、螨虫； 第三，影响你的运气。因为杂物堵塞了运势，旧的不去，新的不来，原本可能会有好运接近你，可能被杂乱挡在门外。当然，这样的说法可能接近与中国的风水学说了，但是有一点我们可以肯定：人生的种种苦恼，往往混杂在对物品的执着中。 实践了断舍离之后，会对人生带来什么改变呢？ 首先，时间变充裕了，减少杂物之后，人能够生活在舒适、有序的环境中，日常维护物品的压力自然减轻，家务活变得简单轻松。可以做更多自己喜欢的事情，比如高质量的陪伴家人。 其次，可以提升你的内在能量，在好的空间里，人与环境相处变得更加和谐，从情绪上远离负面能量，多了正向力量，能感觉到内心的平静、愉快、自在。做事效率更高，更加从容，甚至可以激发更多创作的灵感。 最后，通过限制物品总量，学会更加严格地筛选出自己喜欢的会真正使用的物品，自然提升了品位。 我们为什么舍不得扔东西？作者提出，有三类人会舍不得丢弃物品。 第一类，他们可能是逃避现实的人。因为怕麻烦，不想面对烦心事，但是今天轻松图省事的人，将来都会绊倒在往日的不作为上。 第二类，他们可能是执着过去的人。这是另一种形式的逃避现实。因为每件物品都携带情感和回忆，物品等于复杂的个人历史。过去太美好，不愿意舍弃；过去很灰暗，舍弃的时候会痛苦，也会重新提醒自己曾经的失败。 最后一类是担忧未来的人。这些人的内心没有安全感。淘汰了物品，结果后来要用的时候找不到，所以总是担心。最后一类人群比例的最高的。当然，不是所有人都只属于某一类型，很可能有人是三合一。 那么，作者倡导我们丢掉什么东西呢？ ​ 第一类是不用的东西，总想着有一天要物尽其用，但压根这一天不会来到。第二类是还在用，但不适合自己的 东西，往往只是随便用用，但并不喜欢。第三类是充满回忆的东西，它们身上承载了强大的能量和气场。 如何在生活中实践断舍离呢？第一，任何时候，都以我为主，以我为中心做决定。 要过上以人为主导，而不是以物品为主导的人生。也就是在看待事物的时候，要以我和事物的关系为出发点。 必须只考虑当下的我。 第二，要学会宽恕自己，宽恕他人。人人都有一种言行一致的愿望。我们买回了物品，但没有使用，这等于背弃了当时购买时的承诺，所以很容易产生愧疚感，甚至产生挫败感，不再相信自己的决策力，习惯性的自我否定。这时候要告诉自己，迟迟不处理堆积的杂物，还要经常看到它们，这等于对自己持续不断的负面评判和内心惩罚。 第三，突破“不配得”心理，不将就。什么是“不配得”心理呢？如果平时已经习惯了生活在不喜欢、不需要的事物中，也就是经常处在“将就、凑合”的状态，那么你就是在潜意识里告诉自己“我配不上更好的”。 断舍离的实用行动方法 第一，筛选物品时，标准尽可能简单，舍弃物品时要有仪式感。 第二，个性化安排整理时间，根据能利用的时间段安排整理行动。 第三，收纳时可以参考7、5、1原则和三自原则。 最后，一个动作可以拿到物品。","categories":[{"name":"文艺","slug":"literature","permalink":"http://www,xtslift.top/categories/literature/"}],"tags":[{"name":"整理","slug":"整理","permalink":"http://www,xtslift.top/tags/整理/"},{"name":"舍弃","slug":"舍弃","permalink":"http://www,xtslift.top/tags/舍弃/"},{"name":"心态","slug":"心态","permalink":"http://www,xtslift.top/tags/心态/"}],"keywords":[{"name":"文艺","slug":"literature","permalink":"http://www,xtslift.top/categories/literature/"}]},{"title":"穷查理宝典","slug":"穷查理宝典","date":"2019-04-26T08:11:01.000Z","updated":"2019-04-26T08:45:28.594Z","comments":false,"path":"2019/04/26/穷查理宝典/","link":"","permalink":"http://www,xtslift.top/2019/04/26/穷查理宝典/","excerpt":"","text":"​ 查理·芒格（Charlie Thomas Munger，1924年1月1日—）美国投资家，沃伦·巴菲特的黄金搭档，伯克夏·哈撒韦公司的副主席。 ​ 查理·芒格(Charlie Thomas Munger)，出生于美国内布拉斯加州的奥马哈。这位今年已经95岁高寿的老人，在过去的46年里，他和巴菲特联手创造了有史以来最优秀的投资纪录——伯克希尔公司股票账面价值以年均20.3%的复合收益率创造投资神话，每股股票价格从19美元升至84487美元。 你将获得 什么样的成长经历造就了芒格的巨大成功？ 什么是芒格极力推崇的反向思维？ 如何培养自己的跨学科思维？ 什么是“耐心等待的艺术”？ 书中金句 我这辈子遇到的聪明人没有不每天阅读的——没有，一个都没有。沃伦读书之多，我读书之多，可能会让你感到吃惊。 在手里拿着铁锤的人看来, 世界就像一颗钉子，这是处理问题的一种笨办法。 很小的时候我就明白了这样一个道理：要得到你想要的某样东西，最可靠的办法是让你自己配得上它。 生活之所以如此，是为了让你们能够处理错误。 我之所以能有今天，靠的就是不去追逐平庸的机会。 说真话，你将无须记住你的谎言。 说出一个谎言，就得用无数个谎言去掩盖它。所以，诚实是最好的策略。 精华笔记这本书的作者是谁？​ 作者查理·芒格，是巴菲特的黄金搭档，有“幕后智囊”和“最后的秘密武器”之称，这是一本传记式的名人札记，介绍了主人公查理·芒格的生平和主要思想。 查理·芒格是一个什么样的人？关键词一：家庭芒格出生在大萧条时期，在亲友的相互帮扶下，芒格一家度过了那段艰苦的时光，这段经历让芒格早早地体会到亲情的可贵，他和妻子南希共同抚养8个子女，始终生活在一所老房子里。 关键词二：阅读查理·芒格几乎在任何时候都会随身携带一本书，他说“我手里只要有一本书，就不会觉得浪费时间”。 关键词三：坚韧无论在顺境还是逆境，芒格都喜欢积极地寻找解决办法。一次交通意外让他右眼丧失了90%的视力，但他既不消极放弃，也不怨天尤人，最后奇迹地恢复了视力。 关键词四：睿智和当时绝大多数人不同，芒格对于投资有自己独特的想法，他甚至还发明了一套“人类误判心理学”用来纠正自己的投资观念。 关键词五：搭档巴菲特曾这样形容芒格带给他的帮助：“查理拓展了我的视野。让我以非同寻常的速度从猩猩进化到人类，没有查理，我会比现在贫穷得多”。 关键词六：仁慈热衷于慈善事业，不仅亲自担任几个慈善机构的理事，还为斯坦福大学捐赠了6000千万美元的公益基金。 什么是芒格极力推崇的反向思维？在很多公开场合，芒格本人都表示过，他成功根本原因在于始终坚持用一套方法去处理事情，第一点就是反向思维。 反向思维的含义是说，只要避免让糟糕的决策和糟糕的结果发生，那些美好的事物自然会随之而来，所以在思考问题时，芒格总是从反向开始。 查理·芒格持续不断地收集关于各种人物、企业以及政府管理领域里著名的失败案例，并把这些失败成因写在纸上，每次在做重要的决策前，都会拿出来看一下。 案例：哈佛大学演讲、预测美国金融危机 什么是能力圈？“能力圈”就是指一个人的能力边界，超出能力范围以外的事绝对不要做。如果你无法称职地回答出下一个问题，那就意味着你已经在能力圈之外了，能力圈就是我们的护城河，一旦越界，后果会很危险。 巴菲特说，他们真正的本领是能够弄清楚，自己什么时候在能力圈中心运作，什么时候正在向边缘靠近。 案例：普朗克和他的司机 如何培养自己的跨学科思维？在查理·芒格的眼中，真实的世界里最重要的事情不是分类，而是解决问题，不管是哪个学科的方法，只要有助于解决这个问题，都可以拿来借鉴。 现实生活中，大多数人都试图用一种思维模型来解决所有问题，在手里拿着一把锤子的人眼中，世界只有钉子。想要洞察问题的本质，我们必须要培养自己这种跨学科思考的方式。 方法一是把物理、数学、化学等硬科学，还有心理学、经济学等软科学里的经典概念提炼出来，作为自己的思维模型。 方法二是向不同领域里最顶尖的人才学习。 什么是“耐心等待的艺术”？不要在恰当的时机没来之前就沉不住气，挥棒次数太过频繁的结果，可能就是真正好球来的时候，没有办法全力出击。 案例：棒球手泰勒的挥球技巧、巴菲特的打卡纸 有两个训练方法可以帮助我们强化判断能力，第一个方法叫双轨分析法，第二个方法叫飞行模拟法。 双规分析法：我们一般人在决策的时候，往往要么只从感性角度考虑，要么只从理性角度考虑，很少有人从两方面同时考量一个问题。双轨分析法就是在提醒大家，任何一个问题，都可能比你想象的更复杂。 飞行模拟法：把模拟器上的问题当成真实问题来解决，最好的模拟器是“案例”。","categories":[{"name":"文艺","slug":"literature","permalink":"http://www,xtslift.top/categories/literature/"}],"tags":[{"name":"查理·芒格","slug":"查理·芒格","permalink":"http://www,xtslift.top/tags/查理·芒格/"},{"name":"投资","slug":"投资","permalink":"http://www,xtslift.top/tags/投资/"},{"name":"理财","slug":"理财","permalink":"http://www,xtslift.top/tags/理财/"},{"name":"习惯","slug":"习惯","permalink":"http://www,xtslift.top/tags/习惯/"}],"keywords":[{"name":"文艺","slug":"literature","permalink":"http://www,xtslift.top/categories/literature/"}]},{"title":"My first blog","slug":"My-first-blog","date":"2019-04-26T05:37:02.000Z","updated":"2019-04-26T08:30:19.558Z","comments":false,"path":"2019/04/26/My-first-blog/","link":"","permalink":"http://www,xtslift.top/2019/04/26/My-first-blog/","excerpt":"","text":"​ 近几天花了些时间来做自己的博客，做完了表结构的设计然后又点迷茫不知所措。最后竟然以偷懒的方式先实现了自己的小目标。虽然不是自己完整设计编码的，但还是很开心。本博客借助hexo框架和github来实现的，是入门级的入门级。估计随便来个小白，看看文档也就成了。不过这并不影响，再也不用去担心，电脑上乱七八糟的文档，想要写点自己的东西又很不方便情况。在我的博客，我说了算。 关于自己​ 今天听书的时候听到这样的一句话，很小的时候我就明白了一个道理：要得到你想要的某样东西，最可靠的办法就是让你自己配的上它。生活之所以如此，是为了让你们能够处理错误。是的没错，想要得到某样东西，是要让自己配的上它。当自己的野心得不到满足的时候，我们只能低下头来使自己成长强大，来配的上自己的野心。 关于博客​ 博客要写些什么呢？在今后的日子里我的博客会用来整理和复习编程知识以及新技术学习的总结，将会把他们放在编程类里面。工具里面会放一些工具的相关资源和使用教程，生活会用来记录对自己有意义的事情比如旅游比如纪念日；文艺呢？当然是诗书这样的了呢。文笔这东西，还是的写。近来书看的少了，笔动的少了，想写点东西，半天憋不出一句实属难受。 最后​ 我若不坚强，谁替我勇敢。加油就完事了，我不相信，我也不可能相信我的生活仅仅是现在的样子。","categories":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www,xtslift.top/tags/java/"},{"name":"web","slug":"web","permalink":"http://www,xtslift.top/tags/web/"},{"name":"blog","slug":"blog","permalink":"http://www,xtslift.top/tags/blog/"}],"keywords":[{"name":"编程","slug":"programming","permalink":"http://www,xtslift.top/categories/programming/"}]}]}